---
name: Add concurrent debate execution with phase timeout
status: open
created: 2026-02-11T18:41:29Z
updated: 2026-02-11T18:41:29Z
github: https://github.com/jobu711/option_alpha_v2/issues/37
depends_on: [35, 36]
parallel: false
conflicts_with: []
---

# Task: Add concurrent debate execution with phase timeout

## Description
Replace the sequential `for` loop in `DebateManager.run_debates()` with `asyncio.Semaphore`-gated concurrent execution. Multiple tickers debate in parallel (default concurrency=3), while intra-ticker agent ordering (bull → bear → risk) stays sequential. Add an overall phase timeout so the debate phase returns partial results if it exceeds `ai_debate_phase_timeout`.

## Acceptance Criteria
- [ ] `run_debates()` executes ticker debates concurrently using `asyncio.gather()` with `asyncio.Semaphore`
- [ ] Concurrency limit controlled by `ai_debate_concurrency` setting (default 3)
- [ ] Setting concurrency to 1 disables parallelism (sequential behavior)
- [ ] Intra-ticker agent order preserved: bull → bear → risk (sequential within one debate)
- [ ] Overall phase timeout via `asyncio.wait_for()` using `ai_debate_phase_timeout` (default 600s)
- [ ] On timeout, returns whatever debates completed so far (not an empty list)
- [ ] Failed individual debates still produce conservative fallback results (existing behavior)
- [ ] `progress_callback` still called for each completed debate

## Technical Details
**Files:**
- `src/option_alpha/ai/debate.py` — Refactor `run_debates()` method

**Implementation approach:**
```python
async def run_debates(self, scores, options_recs, top_n, settings, ...):
    sem = asyncio.Semaphore(settings.ai_debate_concurrency)
    results: list[DebateResult] = []
    completed = 0

    async def _debate_one(ticker_score):
        nonlocal completed
        async with sem:
            result = await self.run_debate(ticker_score, options_recs.get(symbol))
            results.append(result)
            completed += 1
            if progress_callback:
                progress_callback(completed, total, symbol)

    tasks = [_debate_one(ts) for ts in candidates]
    try:
        await asyncio.wait_for(
            asyncio.gather(*tasks, return_exceptions=True),
            timeout=settings.ai_debate_phase_timeout,
        )
    except asyncio.TimeoutError:
        logger.warning("Debate phase timed out after %ds, returning %d/%d results",
                       settings.ai_debate_phase_timeout, len(results), total)

    return results
```

**Key considerations:**
- `results.append()` is thread-safe in asyncio (single-threaded event loop)
- `return_exceptions=True` prevents one failed debate from cancelling others
- Fallback results for timed-out debates are handled by the existing `except` in `_debate_one`
- `DebateManager` needs to accept settings (or just concurrency + timeout) — pass via constructor or method param

## Dependencies
- [ ] #35 — Settings with `ai_debate_concurrency` and `ai_debate_phase_timeout`
- [ ] #36 — Agent retry helper (agents called within each debate)

## Effort Estimate
- Size: S
- Hours: 0.5
- Parallel: false (depends on #35 + #36)

## Definition of Done
- [ ] Concurrent debate execution working
- [ ] Phase timeout returning partial results
- [ ] Concurrency=1 produces identical results to current sequential behavior
- [ ] Existing tests still pass
